// -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
//
// Copyright (C) 2012 Opera Software ASA.  All rights reserved.
//
// This file is an original work developed by Opera Software ASA
#include <sstream>

#include "testing/gtest/include/gtest/gtest.h"
#include "testing/gmock/include/gmock/gmock.h"
#include "common/ini_parser/ini_parser.h"

using ::testing::Test;

namespace opera {
namespace common {

TEST(IniParserTest, BeforeParsing) {
  IniParser parser;
  EXPECT_FALSE(parser.HasValue("badsection", "badkey"));
  EXPECT_EQ("defaultValue", parser.Get("badsection", "badkey", "defaultValue"));
}

TEST(IniParserTest, ParseEmptyInput) {
  IniParser parser;
  std::stringstream input;
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_FALSE(parser.HasValue("badsection", "badkey"));
  EXPECT_EQ("defaultValue", parser.Get("badsection", "badkey", "defaultValue"));
}

TEST(IniParserTest, CommonOperaHeader) {
  IniParser parser;
  std::stringstream input;
  input << "\xEF\xBB\xBFOpera Preferences version 2.1\n";
  input << "; Do not edit this file while Opera is running\n";
  input << "; This file is stored in UTF-8 encoding\n";
  input << "\n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_FALSE(parser.HasValue("badsection", "badkey"));
  EXPECT_EQ("defaultValue", parser.Get("badsection", "badkey", "defaultValue"));
}

TEST(IniParserTest, TopLevelProperties) {
  IniParser parser;
  std::stringstream input;
  input << "\xEF\xBB\xBFOpera Preferences version 2.1\n";
  input << "; Do not edit this file while Opera is running\n";
  input << "; This file is stored in UTF-8 encoding\n";
  input << "\n";
  input << "key1 = value1 \n";
  input << "key2=value2\n";
  input << "key3=\n";
  input << "key4\n";
  input << "key5 = many words here, ; not a comment\n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_FALSE(parser.HasValue("badsection", "key1"));
  EXPECT_FALSE(parser.HasValue("badsection", "key2"));
  EXPECT_FALSE(parser.HasValue("badsection", "key3"));
  EXPECT_FALSE(parser.HasValue("badsection", "key4"));
  EXPECT_FALSE(parser.HasValue("badsection", "key5"));
  EXPECT_TRUE(parser.HasValue("", "key1"));
  EXPECT_TRUE(parser.HasValue("", "key2"));
  EXPECT_TRUE(parser.HasValue("", "key3"));
  EXPECT_TRUE(parser.HasValue("", "key4"));
  EXPECT_TRUE(parser.HasValue("", "key5"));
  EXPECT_EQ("value1", parser.Get("", "key1", "defaultValue"));
  EXPECT_EQ("value2", parser.Get("", "key2", "defaultValue"));
  EXPECT_EQ("", parser.Get("", "key3", "defaultValue"));
  EXPECT_EQ("", parser.Get("", "key4", "defaultValue"));
  EXPECT_EQ("many words here, ; not a comment",
      parser.Get("", "key5", "defaultValue"));
}

TEST(IniParserTest, Sections) {
  IniParser parser;
  std::stringstream input;
  input << "\xEF\xBB\xBFOpera Preferences version 2.1\n";
  input << "; Do not edit this file while Opera is running\n";
  input << "; This file is stored in UTF-8 encoding\n";
  input << "\n";
  input << "key1 = value1 \n";
  input << "key2=value2\n";
  input << "key3=\n";
  input << "key4\n";
  input << "key5 = many words here, ; not a comment\n";
  input << "\n";
  input << "[MySection1]\n";
  input << "key1 = sec1value1 \n";
  input << "[MySection2]\n";
  input << "key1 = sec2value1 \n";
  input << "key6 = sec2value6 \n";
  input << "\n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_FALSE(parser.HasSection("badsection"));
  EXPECT_FALSE(parser.HasValue("badsection", "key1"));
  EXPECT_FALSE(parser.HasValue("badsection", "key2"));
  EXPECT_FALSE(parser.HasValue("badsection", "key3"));
  EXPECT_FALSE(parser.HasValue("badsection", "key4"));
  EXPECT_FALSE(parser.HasValue("badsection", "key5"));
  EXPECT_TRUE(parser.HasValue("", "key1"));
  EXPECT_TRUE(parser.HasValue("", "key2"));
  EXPECT_TRUE(parser.HasValue("", "key3"));
  EXPECT_TRUE(parser.HasValue("", "key4"));
  EXPECT_TRUE(parser.HasValue("", "key5"));
  EXPECT_TRUE(parser.HasSection("MySection1"));
  EXPECT_TRUE(parser.HasSection("MySection2"));
  EXPECT_TRUE(parser.HasValue("MySection1", "key1"));
  EXPECT_TRUE(parser.HasValue("MySection2", "key1"));
  EXPECT_TRUE(parser.HasValue("MySection2", "key6"));
  EXPECT_FALSE(parser.HasValue("MySection1", "key3"));
  EXPECT_FALSE(parser.HasValue("MySection2", "key4"));

  EXPECT_EQ("value1", parser.Get("", "key1", "defaultValue"));
  EXPECT_EQ("value2", parser.Get("", "key2", "defaultValue"));
  EXPECT_EQ("", parser.Get("", "key3", "defaultValue"));
  EXPECT_EQ("", parser.Get("", "key4", "defaultValue"));
  EXPECT_EQ("many words here, ; not a comment",
      parser.Get("", "key5", "defaultValue"));

  EXPECT_EQ("sec1value1", parser.Get("MySection1", "key1", "defaultValue"));
  EXPECT_EQ("sec2value1", parser.Get("MySection2", "key1", "defaultValue"));
  EXPECT_EQ("sec2value6", parser.Get("MySection2", "key6", "defaultValue"));
}

TEST(IniParserTest, MalformedSection) {
  IniParser parser;
  std::stringstream input;
  input << "[MySection1\n";  // No closing brace
  input << "key1 = sec1value1 \n";
  EXPECT_FALSE(parser.Parse(&input));

  EXPECT_FALSE(parser.HasValue("MySection1", "key1"));
}

TEST(IniParserTest, FalseDelimiters) {
  IniParser parser;
  std::stringstream input;
  input << "[MySection1]\n";
  input << "key1 = sec1value1=these=are=not=delimiters \n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_EQ("sec1value1=these=are=not=delimiters",
            parser.Get("MySection1", "key1", "defaultValue"));
}

TEST(IniParserTest, GetAsInt) {
  IniParser parser;
  std::stringstream input;
  input << "[MySection1]\n";
  input << "key1 = 55 \n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_EQ(55, parser.GetAs<int>("MySection1", "key1", 42));
}

TEST(IniParserTest, GetAsBool) {
  IniParser parser;
  std::stringstream input;
  input << "[MySection1]\n";
  input << "key1 = 1 \n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_TRUE(parser.GetAs<bool>("MySection1", "key1", false));
}

TEST(IniParserTest, GetAsBoolText) {
  IniParser parser;
  std::stringstream input;
  input << "[MySection1]\n";
  input << "key1 = True \n";
  input << "key2 = False \n";
  input << "key3 = on \n";
  input << "key4 = off \n";
  input << "key5 = ENABLED \n";
  input << "key6 = disabled \n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_TRUE(parser.GetAs<bool>("MySection1", "key1", false));
  EXPECT_FALSE(parser.GetAs<bool>("MySection1", "key2", true));
  EXPECT_TRUE(parser.GetAs<bool>("MySection1", "key3", false));
  EXPECT_FALSE(parser.GetAs<bool>("MySection1", "key4", true));
  EXPECT_TRUE(parser.GetAs<bool>("MySection1", "key5", false));
  EXPECT_FALSE(parser.GetAs<bool>("MySection1", "key6", true));
}

TEST(IniParserTest, GetAsBoolUnrecognizedText) {
  IniParser parser;
  std::stringstream input;
  input << "[MySection1]\n";
  input << "key1 = asdgafsdg \n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_FALSE(parser.GetAs<bool>("MySection1", "key1", false));
  EXPECT_TRUE(parser.GetAs<bool>("MySection1", "key1", true));
}

TEST(IniParserTest, GetAsIntCantParse) {
  IniParser parser;
  std::stringstream input;
  input << "[MySection1]\n";
  input << "key1 = not_an_int \n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_EQ(42, parser.GetAs<int>("MySection1", "key1", 42));
}

TEST(IniParserTest, GetAsIntCantFind) {
  IniParser parser;
  std::stringstream input;
  input << "[MySection1]\n";
  EXPECT_TRUE(parser.Parse(&input));
  EXPECT_EQ(42, parser.GetAs<int>("MySection1", "key1", 42));
}

}  // namespace common
}  // namespace opera
